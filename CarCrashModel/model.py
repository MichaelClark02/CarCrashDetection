# -*- coding: utf-8 -*-
"""Untitled9 (3).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VZ83SNDYHOsE9RFOdsyy0ZRkPZMXgoig
"""

import pandas as pd
import numpy as np
import cv2
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix
from google.colab.patches import cv2_imshow

df = pd.read_csv("/content/sample_data/table/Crash_Table.csv")
df

X = []  # List to store image data
y = []

# Label encoder to encode crash and no crash labels
label_encoder = LabelEncoder()

# Define the base file name for the image sequence
base_filename = "C_000010_"

# Define the number of videos and frames per video
num_videos = 10
frames_per_video = 50

# Loop over each video
for video_index in range(1, num_videos + 1):
    file_path = "/content/sample_data/CrashBest/"
    # Define the base filename for the video
    base_filename = f"{file_path}C_{video_index:06d}_"

    # Loop over each frame in the video
    for frame_index in range(1, frames_per_video + 1):
        image_filename = base_filename + f"{frame_index:02d}.jpg"  # Update frame_number to frame_index

        frame = cv2.imread(image_filename)

        if frame is not None:
            # Process the frame (e.g., resize, normalize, feature extraction)
            processed_frame = cv2.resize(frame, (64, 64))  # Resize the frame to 64x64 pixels

            # Determine the label based on the image filename
            label = 1 if f"C_{video_index:06d}_" in image_filename else 0

            X.append(processed_frame)
            y.append(label)

            # Display the processed frame using cv2_imshow
            cv2_imshow(frame)
        else:
            print(f"Failed to load frame: {image_filename}")

# Encode labels (1 for car crashes, 0 for no car crash)
y = label_encoder.fit_transform(y)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

datagen = ImageDataGenerator(
    rotation_range=40,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

# Fit the data augmentation generator on your training data
datagen.fit(X_train)

# Create the model
# model = keras.Sequential([
#     layers.Conv2D(16, (3, 3), activation='relu', input_shape=(64, 64, 3)),
#     layers.MaxPooling2D((2, 2)),
#     layers.Conv2D(32, (3, 3), activation='relu'),
#     layers.MaxPooling2D((2, 2)),
#     layers.Conv2D(64, (3, 3), activation='relu'),
#     layers.Flatten(),
#     layers.Dense(32, activation='relu'),
#     layers.Dense(1, activation='sigmoid')
# ])
model = keras.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(64, 64, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(128, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dropout(0.5),  # Adding dropout for regularization
    layers.Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='mean_squared_error')

# Check that the number of training samples matches the number of labels
if len(X_train) != len(y_train):
    raise ValueError("X_train and y_train should have the same number of samples.")

# Train the model
history = model.fit(np.array(X_train), np.array(y_train), epochs=10, validation_data=(np.array(X_test), np.array(y_test)))

model.summary()

print("X_train shape:", np.array(X_train).shape)
print("y_train shape:", np.array(y_train).shape)
print("X_test shape:", np.array(X_test).shape)
print("y_test shape:", np.array(y_test).shape)

# Make predictions on the test set
y_pred = model.predict(np.array(X_test))
y_pred = (y_pred > 0.5).astype(int)  # Convert probabilities to binary predictions (0 or 1)

conf_matrix = confusion_matrix(y_test, y_pred)
print(conf_matrix)

# Adjust the threshold for binary predictions
threshold = 0.2  # Example threshold value
y_pred = model.predict(np.array(X_test))
y_pred = (y_pred > threshold).astype(int)

# Calculate precision, recall, and F1 Score with the adjusted predictions
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)

print(f"Precision: {precision:.2f}")
print(f"Recall: {recall:.2f}")
print(f"F1 Score: {f1:.2f}")

model.save('car_crash.h5')

from tensorflow.keras.models import load_model
# Load your trained model
crash_model = load_model('car_crash.h5')

# Open the video file
video_file = 'dashcam_2.mp4'
cap = cv2.VideoCapture(video_file)

import os

# Directory where your JPEG image files are located
image_directory = "/content/sample_data/test"

# List of image file names
image_files = [f"C_000037_{i:02d}.jpg" for i in range(1, 51)]

for image_file in image_files:
    # Load the image
    image_path = os.path.join(image_directory, image_file)
    frame = cv2.imread(image_path)
    if frame is not None:
        processed_frame = cv2.resize(frame, (64, 64)) / 255.0
        input_data = np.array([processed_frame])
        prediction = crash_model.predict(input_data)
        if prediction[0] > 0.5:
            result = "Crash"
        else:
            result = "No Crash"
        print(f"{image_file}: {result}")
    else:
        print(f"Failed to load frame: {image_file}")



import os
import cv2
import random
from PIL import Image
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation

import sys
import imageio

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers, losses
from tensorflow.keras.models import Model
from tensorflow.keras.utils import plot_model

yolo = tf.keras.models.load_model("/content/sample_data/yolov3-model/YoloV3.h5")

yolo.summary()

WINDOW = 10
FUTURE = 5
DIMENSION = 256
FILTER = 64

yolo.layers[-3].output

plot_model(yolo, show_shapes=True, show_layer_names=False)

WINDOW = 10
FUTURE = 5
DIMENSION = 256
FILTER = 64

#inputs = tf.keras.Input(shape=(8, 8, 255))

b1c1 = layers.Conv2D(FILTER, (3, 3), padding="same", activation="relu")(yolo.layers[-3].output)
b1c2 = layers.Conv2D(FILTER, (3, 3), padding="same", activation="relu")(b1c1)
#rs = layers.Reshape((256, 256, FILTER))(b1c2)
mp1 = layers.MaxPooling2D((2, 2))(b1c2)

b2c1 = layers.Conv2D(FILTER * 2, (3, 3), padding="same", activation="relu")(mp1)
b2c2 = layers.Conv2D(FILTER * 2, (3, 3), padding="same", activation="relu")(b2c1)
mp2 = layers.MaxPooling2D((2, 2))(b2c2)

b3c1 = layers.Conv2D(FILTER * 4, (3, 3), padding="same", activation="relu")(mp2)
b3c2 = layers.Conv2D(FILTER * 4, (3, 3), padding="same", activation="relu")(b3c1)
mp3 = layers.MaxPooling2D((2, 2))(b3c2)

#flat = layers.Flatten()(mp3)
fc1 = layers.Dense(128, activation="relu")(mp3)
fc2 = layers.Dense(16, activation="relu")(fc1)
outputs = layers.Dense(1, activation="sigmoid")(fc2)

model = Model(inputs=yolo.input, outputs=outputs, name="AE")
model.compile(optimizer='adam', loss="mse", metrics = ['binary_accuracy'])

plot_model(model, show_shapes=True, show_layer_names=False)

FILENAME = "C_000001_"
FRAME = "50"
SCALE = 4

# Construct the file path
image_path = FILENAME + FRAME + ".jpg"

# Check if the image file exists
if cv2.os.path.exists(image_path):
    img = cv2.imread(image_path)
    if img is not None:
        img = cv2.resize(img, (256, 256))
        img = img / 255
        plt.imshow(img[:, :, ::-1])
    else:
        print("Failed to load the image.")
else:
    print("Image file not found:", image_path)

TABLENAME = "/content/sample_data/table/Crash_Table.csv"

df = pd.read_csv(TABLENAME)
#print(df.columns)

arr = []

for ind in df.index:
    for i in range(1, 51):
        arr.append(df[f"frame_{i}"][ind])

print(len(arr))

BASE_PATH = "/content/sample_data/CrashBest/*"

images_ds = tf.data.Dataset.list_files(BASE_PATH, shuffle=False)
new_arr = tf.stack(arr)

FUTURE = 0

def get_label(file_path):
    parts = tf.strings.split(file_path, "_")
    vidname = int(parts[1])

    f = tf.strings.split(parts[2], ".")
    frame = int(f[0])

    if frame - 1 + FUTURE >= 50:
        return 1

    crash = new_arr[((vidname - 1) * 50) + frame - 1 + FUTURE]
    return crash


def process_image(file_path):
    label = get_label(file_path)
    img = tf.io.read_file(file_path)
    img = tf.image.decode_jpeg(img)
    img = img / 255
    img = tf.image.resize(img, [DIMENSION, DIMENSION])
    #img = yolo.predict(img)#.reshape(-1,DIMENSION, DIMENSION, 3))[0]#.reshape(DIMENSION, DIMENSION, 3)

    return img, label


images_ds = images_ds.map(process_image)
